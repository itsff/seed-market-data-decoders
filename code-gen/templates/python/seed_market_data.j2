import struct
import enum


class ExchangeAssignedId:
    def __init__(self, byte_payload: bytes):
        self._bytes = byte_payload

    def __repr__(self):
        return repr(self._bytes)

    def __str__(self):
        hi = int.from_bytes(self._bytes,
                            byteorder='little',
                            signed=False)
        if hi == 0:
            # Return result as number
            val = int.from_bytes(self._bytes,
                                 byteorder='little',
                                 signed=False)
            return str(val)
        else:
            # TODO: return base58.encode(self._bytes)
            return repr(self)

    def __eq__(self, o: object) -> bool:
        if isinstance(o, self.__class__):
            return self._bytes == o._bytes
        return False

    def __ne__(self, o: object) -> bool:
        return not self.__eq__(o)

    def __hash__(self) -> int:
        if self._bytes:
            return self._bytes.__hash__()
        return 0


class OrderId(ExchangeAssignedId):
    def __init__(self, byte_payload: bytes):
        super().__init__(byte_payload)


class ExecutionId(ExchangeAssignedId):
    def __init__(self, byte_payload: bytes):
        super().__init__(byte_payload)


class classproperty(property):
    def __get__(self, cls, owner):
        return classmethod(self.fget).__get__(None, owner)()


{% for enum in enums %}
class {{ enum.name | pascal }}Enum(enum.IntEnum):
    {% for item in enum.items %}
    {{ item.name | snake }} = {{ item.value }},
    {% endfor %}


{% endfor %}


{% for segment in segments %}

class {{ segment.name | pascal }}:
    _EXPECTED_WIRE_SIZE = (0
    {% for f in segment.all_fields %}
        + {{ f.size }}  # {{ f.name | snake }}
    {% endfor %}
        )

    @classproperty
    def expected_wire_size(cls):
        return cls._EXPECTED_WIRE_SIZE

    def __init__(self):
        {% for f in segment.fields %}
        self.{{ f.name | snake }} = None
        {% endfor %}
        pass

    def __repr__(self):
        {% if segment.has_fields %}
        return ("{{ segment.name | pascal }} {"
            {% for f in segment.fields %}
            "{% if not loop.first %}, {% endif %}{{ f.name | snake }}={{ '{' }}{{ loop.index - 1 }}{{ '}' }}"
            {% endfor %}
            "}").format(
            {% for f in segment.fields %}
            {{ '' }}self.{{ f.name | snake }}{% if not loop.last %},
            {% endif %}
            {% endfor %})
        {% else %}
        return "{{ segment.name | pascal }}"
        {% endif %}

    @staticmethod
    def parse_from(buffer, offset):
        {% if segment.has_fields %}
        fmt = '{% for f in segment.all_fields %}{{ gen.get_struct_format(f) }}{% endfor %}'
        values = struct.unpack_from(fmt, buffer, offset)

        me = {{ segment.name | pascal }}()
        {% for f in segment.fields %}
        me.{{ f.name | snake }} = {% if gen.get_lang_type(f) %}{{ gen.get_lang_type(f) }}(values[{{ loop.index - 1 }}]){% else %}values[{{ loop.index - 1 }}]{% endif %}

        {% endfor %}

        return me
        {% else %}
        return {{ segment.name | pascal }}()
        {% endif %}

{% endfor %}


def is_heartbeat(packet_header: PacketHeader):
    return packet_header.message_count == 0

